import { App, TFile, moment } from 'obsidian';
import type { ClaritySettings } from '../settings';
import type { SpiralData } from '../components/ReframeModal';
import type { ReframeResult } from '../components/ResultModal';

export interface LogEntry {
	spiral: SpiralData;
	reframe: ReframeResult;
	moodAfter?: number;
	wasHelpful?: boolean; // Effectiveness rating
}

export class SpiralLogger {
	private app: App;
	private settings: ClaritySettings;

	constructor(app: App, settings: ClaritySettings) {
		this.app = app;
		this.settings = settings;
	}

	/**
	 * Log a spiral and reframe to the appropriate log file
	 * Helpful reframes go to main logs, unhelpful go to archive
	 */
	async logEntry(entry: LogEntry): Promise<void> {
		const isHelpful = entry.wasHelpful !== false; // Default to helpful
		const logFolder = isHelpful
			? this.settings.logFolder
			: `${this.settings.logFolder}/Archived - Unhelpful`;

		const logPath = this.getLogPath(logFolder);
		const content = this.formatEntry(entry);

		// Ensure log folder exists
		await this.ensureFolderExists(logFolder);

		// Get or create log file
		let file = this.app.vault.getAbstractFileByPath(logPath);

		if (!file) {
			// Create new file with header
			const header = this.getLogHeader(isHelpful);
			await this.app.vault.create(logPath, header + '\n\n' + content);
		} else if (file instanceof TFile) {
			// Append to existing file
			const existingContent = await this.app.vault.read(file);
			await this.app.vault.modify(file, existingContent + '\n\n' + content);
		}
	}

	/**
	 * Get the path for today's log file
	 */
	private getLogPath(folder: string): string {
		const today = moment().format('YYYY-MM-DD');
		return `${folder}/${today}.md`;
	}

	/**
	 * Get the header for a new log file
	 */
	private getLogHeader(isHelpful: boolean): string {
		const today = moment().format('YYYY-MM-DD');
		const dayName = moment().format('dddd');
		const tags = isHelpful
			? 'clarity\n  - spiral-log'
			: 'clarity\n  - spiral-log\n  - unhelpful';

		return `---
tags:
  - ${tags}
date: ${today}
---
# Clarity Log - ${today} (${dayName})${isHelpful ? '' : ' - Unhelpful Archive'}`;
	}

	/**
	 * Format a log entry
	 */
	private formatEntry(entry: LogEntry): string {
		const time = moment().format('HH:mm');
		const { spiral, reframe, moodAfter, wasHelpful } = entry;

		let content = `## ${time}\n\n`;
		content += `**Spiral:** ${spiral.narrative}\n`;
		content += `**Certainty:** ${spiral.certainty}/10\n`;

		if (spiral.context) {
			content += `**Context:** ${spiral.context}\n`;
		}

		if (spiral.moodBefore !== undefined) {
			content += `**Mood Before:** ${spiral.moodBefore}/10\n`;
		}

		content += `\n### Reframe\n\n${reframe.content}\n`;

		if (moodAfter !== undefined) {
			content += `\n**Mood After:** ${moodAfter}/10\n`;
		}

		// Add effectiveness rating
		if (wasHelpful !== undefined) {
			content += `\n**Helpful:** ${wasHelpful ? '✅ Yes' : '❌ No'}\n`;
		}

		if (reframe.sources.length > 0) {
			content += `\n**Sources:** ${reframe.sources.join(', ')}\n`;
		}

		content += `\n*Generated by ${this.getProviderName(reframe.provider)}*`;

		return content;
	}

	/**
	 * Ensure a folder exists, creating it if necessary (recursive)
	 */
	private async ensureFolderExists(folderPath: string): Promise<void> {
		const folder = this.app.vault.getAbstractFileByPath(folderPath);
		if (!folder) {
			// Create parent folders if needed
			const parts = folderPath.split('/');
			let currentPath = '';
			for (const part of parts) {
				currentPath = currentPath ? `${currentPath}/${part}` : part;
				const existing = this.app.vault.getAbstractFileByPath(currentPath);
				if (!existing) {
					await this.app.vault.createFolder(currentPath);
				}
			}
		}
	}

	/**
	 * Get display name for provider
	 */
	private getProviderName(provider: string): string {
		switch (provider) {
			case 'gemini': return 'Gemini';
			case 'claude-sonnet': return 'Claude Sonnet 4.5';
			case 'claude-haiku': return 'Claude Haiku';
			case 'pattern': return 'Cached Pattern';
			default: return provider;
		}
	}
}
